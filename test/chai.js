(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chai = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  module.exports = require('./lib/chai');


},{"./lib/chai":2}],2:[function(require,module,exports){
  /*!
   *  * chai
   *   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   *    * MIT Licensed
   *     */

  var used = [];

  /*!
   *  * Chai version
   *   */

  exports.version = '4.2.0';

  /*!
   *  * Assertion Error
   *   */

  exports.AssertionError = require('assertion-error');

  /*!
   *  * Utils for plugins (not exported)
   *   */

  var util = require('./chai/utils');

  /**
   *  * # .use(function)
   *   *
   *    * Provides a way to extend the internals of Chai.
   *     *
   *      * @param {Function}
   *       * @returns {this} for chaining
   *        * @api public
   *         */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
          fn(exports, util);
              used.push(fn);
                
    }

      return exports;

  };

  /*!
   *  * Utility Functions
   *   */

  exports.util = util;

  /*!
   *  * Configuration
   *   */

  var config = require('./chai/config');
  exports.config = config;

  /*!
   *  * Primary `Assertion` prototype
   *   */

  var assertion = require('./chai/assertion');
  exports.use(assertion);

  /*!
   *  * Core Assertions
   *   */

  var core = require('./chai/core/assertions');
  exports.use(core);

  /*!
   *  * Expect interface
   *   */

  var expect = require('./chai/interface/expect');
  exports.use(expect);

  /*!
   *  * Should interface
   *   */

  var should = require('./chai/interface/should');
  exports.use(should);

  /*!
   *  * Assert interface
   *   */

  var assert = require('./chai/interface/assert');
  exports.use(assert);


},{"./chai/assertion":3,"./chai/config":4,"./chai/core/assertions":5,"./chai/interface/assert":6,"./chai/interface/expect":7,"./chai/interface/should":8,"./chai/utils":22,"assertion-error":33}],3:[function(require,module,exports){
  /*!
   *  * chai
   *   * http://chaijs.com
   *    * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   *     * MIT Licensed
   *      */

  var config = require('./config');

  module.exports = function (_chai, util) {
      /*!
       *    * Module dependencies.
       *       */

      var AssertionError = _chai.AssertionError
            , flag = util.flag;

        /*!
         *    * Module export.
         *       */

        _chai.Assertion = Assertion;

          /*!
           *    * Assertion Constructor
           *       *
           *          * Creates object for chaining.
           *             *
           *                * `Assertion` objects contain metadata in the form of flags. Three flags can
           *                   * be assigned during instantiation by passing arguments to this constructor:
           *                      *
           *                         * - `object`: This flag contains the target of the assertion. For example, in
           *                            *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
           *                               *   contain `numKittens` so that the `equal` assertion can reference it when
           *                                  *   needed.
           *                                     *
           *                                        * - `message`: This flag contains an optional custom error message to be
           *                                           *   prepended to the error message that's generated by the assertion when it
           *                                              *   fails.
           *                                                 *
           *                                                    * - `ssfi`: This flag stands for "start stack function indicator". It
           *                                                       *   contains a function reference that serves as the starting point for
           *                                                          *   removing frames from the stack trace of the error that's created by the
           *                                                             *   assertion when it fails. The goal is to provide a cleaner stack trace to
           *                                                                *   end users by removing Chai's internal functions. Note that it only works
           *                                                                   *   in environments that support `Error.captureStackTrace`, and only when
           *                                                                      *   `Chai.config.includeStack` hasn't been set to `false`.
           *                                                                         *
           *                                                                            * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
           *                                                                               *   should retain its current value, even as assertions are chained off of
           *                                                                                  *   this object. This is usually set to `true` when creating a new assertion
           *                                                                                     *   from within another assertion. It's also temporarily set to `true` before
           *                                                                                        *   an overwritten assertion gets called by the overwriting assertion.
           *                                                                                           *
           *                                                                                              * @param {Mixed} obj target of the assertion
           *                                                                                                 * @param {String} msg (optional) custom error message
           *                                                                                                    * @param {Function} ssfi (optional) starting point for removing stack frames
           *                                                                                                       * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
           *                                                                                                          * @api private
           *                                                                                                             */

        function Assertion (obj, msg, ssfi, lockSsfi) {
              flag(this, 'ssfi', ssfi || Assertion);
                  flag(this, 'lockSsfi', lockSsfi);
                      flag(this, 'object', obj);
                          flag(this, 'message', msg);

                              return util.proxify(this);
                                
        }

        Object.defineProperty(Assertion, 'includeStack', {
          get: function() {
                  console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
                        return config.includeStack;
                            
          },
        set: function(value) {
                console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
                      config.includeStack = value;
                          
        }
          
        });

        Object.defineProperty(Assertion, 'showDiff', {
          get: function() {
                  console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
                        return config.showDiff;
                            
          },
          set: function(value) {
                  console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
                        config.showDiff = value;
                            
          }
          
        });

        Assertion.addProperty = function (name, fn) {
              util.addProperty(this.prototype, name, fn);
                
        };

        Assertion.addMethod = function (name, fn) {
              util.addMethod(this.prototype, name, fn);
                
        };

        Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
              util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
                
        };

        Assertion.overwriteProperty = function (name, fn) {
              util.overwriteProperty(this.prototype, name, fn);
                
        };

        Assertion.overwriteMethod = function (name, fn) {
              util.overwriteMethod(this.prototype, name, fn);
                
        };

        Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
              util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
                
        };

          /**
           *    * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
           *       *
           *          * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
           *             *
           *                * @name assert
           *                   * @param {Philosophical} expression to be tested
           *                      * @param {String|Function} message or function that returns message to display if expression fails
           *                         * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
           *                            * @param {Mixed} expected value (remember to check for negation)
           *                               * @param {Mixed} actual (optional) will default to `this.obj`
           *                                  * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
           *                                     * @api private
           *                                        */

        Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
              var ok = util.test(this, arguments);
                  if (false !== showDiff) showDiff = true;
                      if (undefined === expected && undefined === _actual) showDiff = false;
                          if (true !== config.showDiff) showDiff = false;

                          if (!ok) {
                                  msg = util.getMessage(this, arguments);
                                        var actual = util.getActual(this, arguments);
                                        throw new AssertionError(msg, {
                                                    actual: actual
                                                  , expected: expected
                                                  , showDiff: showDiff
                                                
                                        }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
                                            
                          }
                            
        };

          /*!
           *    * ### ._obj
           *       *
           *          * Quick reference to stored `actual` value for plugin developers.
           *             *
           *                * @api private
           *                   */

          Object.defineProperty(Assertion.prototype, '_obj',
              { get: function () {
                                           return flag(this, 'object');
                                                 
                                 }
              , set: function (val) {
                        flag(this, 'object', val);
                              
              }
                });

  };


},{"./config":4}],4:[function(require,module,exports){
  module.exports = {

      /**
       *    * ### config.includeStack
       *       *
       *          * User configurable property, influences whether stack trace
       *             * is included in Assertion error message. Default of false
       *                * suppresses stack trace in the error message.
       *                   *
       *                      *     chai.config.includeStack = true;  // enable stack on error
       *                         *
       *                            * @param {Boolean}
       *                               * @api public
       *                                  */

      includeStack: false,

        /**
         *    * ### config.showDiff
         *       *
         *          * User configurable property, influences whether or not
         *             * the `showDiff` flag should be included in the thrown
         *                * AssertionErrors. `false` will always be `false`; `true`
         *                   * will be true when the assertion has requested a diff
         *                      * be shown.
         *                         *
         *                            * @param {Boolean}
         *                               * @api public
         *                                  */

        showDiff: true,

          /**
           *    * ### config.truncateThreshold
           *       *
           *          * User configurable property, sets length threshold for actual and
           *             * expected values in assertion errors. If this threshold is exceeded, for
           *                * example for large data structures, the value is replaced with something
           *                   * like `[ Array(3)  ]` or `{ Object (prop1, prop2)  }`.
           *                      *
           *                         * Set it to zero if you want to disable truncating altogether.
           *                            *
           *                               * This is especially userful when doing assertions on arrays: having this
           *                                  * set to a reasonable large value makes the failure messages readily
           *                                     * inspectable.
           *                                        *
           *                                           *     chai.config.truncateThreshold = 0;  // disable truncating
           *                                              *
           *                                                 * @param {Number}
           *                                                    * @api public
           *                                                       */

          truncateThreshold: 40,

            /**
             *    * ### config.useProxy
             *       *
             *          * User configurable property, defines if chai will use a Proxy to throw
             *             * an error when a non-existent property is read, which protects users
             *                * from typos when using property-based assertions.
             *                   *
             *                      * Set it to false if you want to disable this feature.
             *                         *
             *                            *     chai.config.useProxy = false;  // disable use of Proxy
             *                               *
             *                                  * This feature is automatically disabled regardless of this config value
             *                                     * in environments that don't support proxies.
             *                                        *
             *                                           * @param {Boolean}
             *                                              * @api public
             *                                                 */

            useProxy: true,

              /**
               *    * ### config.proxyExcludedKeys
               *       *
               *          * User configurable property, defines which properties should be ignored
               *             * instead of throwing an error if they do not exist on the assertion.
               *                * This is only applied if the environment Chai is running in supports proxies and
               *                   * if the `useProxy` configuration setting is enabled.
               *                      * By default, `then` and `inspect` will not throw an error if they do not exist on the
               *                         * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
               *                            * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
               *                               *
               *                                  *     // By default these keys will not throw an error if they do not exist on the assertion object
               *                                     *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
               *                                        *
               *                                           * @param {Array}
               *                                              * @api public
               *                                                 */

              proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']

  };


},{}],5:[function(require,module,exports){
  /*!
   *  * chai
   *   * http://chaijs.com
   *    * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   *     * MIT Licensed
   *      */

  module.exports = function (chai, _) {
      var Assertion = chai.Assertion
            , AssertionError = chai.AssertionError
                , flag = _.flag;

        /**
         *    * ### Language Chains
         *       *
         *          * The following are provided as chainable getters to improve the readability
         *             * of your assertions.
         *                *
         *                   * **Chains**
         *                      *
         *                         * - to
         *                            * - be
         *                               * - been
         *                                  * - is
         *                                     * - that
         *                                        * - which
         *                                           * - and
         *                                              * - has
         *                                                 * - have
         *                                                    * - with
         *                                                       * - at
         *                                                          * - of
         *                                                             * - same
         *                                                                * - but
         *                                                                   * - does
         *                                                                      * - still
         *                                                                         *
         *                                                                            * @name language chains
         *                                                                               * @namespace BDD
         *                                                                                  * @api public
         *                                                                                     */

        [ 'to', 'be', 'been', 'is'
            , 'and', 'has', 'have', 'with'
              , 'that', 'which', 'at', 'of'
              , 'same', 'but', 'does', 'still' ].forEach(function (chain) {
                    Assertion.addProperty(chain);
                      
              });

          /**
           *    * ### .not
           *       *
           *          * Negates all assertions that follow in the chain.
           *             *
           *                *     expect(function () {}).to.not.throw();
           *                   *     expect({a: 1}).to.not.have.property('b');
           *                      *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
           *                         *
           *                            * Just because you can negate any assertion with `.not` doesn't mean you
           *                               * should. With great power comes great responsibility. It's often best to
           *                                  * assert that the one expected output was produced, rather than asserting
           *                                     * that one of countless unexpected outputs wasn't produced. See individual
           *                                        * assertions for specific guidance.
           *                                           *
           *                                              *     expect(2).to.equal(2); // Recommended
           *                                                 *     expect(2).to.not.equal(1); // Not recommended
           *                                                    *
           *                                                       * @name not
           *                                                          * @namespace BDD
           *                                                             * @api public
           *                                                                */

        Assertion.addProperty('not', function () {
              flag(this, 'negate', true);
                
        });

          /**
           *    * ### .deep
           *       *
           *          * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
           *             * assertions that follow in the chain to use deep equality instead of strict
           *                * (`===`) equality. See the `deep-eql` project page for info on the deep
           *                   * equality algorithm: https://github.com/chaijs/deep-eql.
           *                      *
           *                         *     // Target object deeply (but not strictly) equals `{a: 1}`
           *                            *     expect({a: 1}).to.deep.equal({a: 1});
           *                               *     expect({a: 1}).to.not.equal({a: 1});
           *                                  *
           *                                     *     // Target array deeply (but not strictly) includes `{a: 1}`
           *                                        *     expect([{a: 1}]).to.deep.include({a: 1});
           *                                           *     expect([{a: 1}]).to.not.include({a: 1});
           *                                              *
           *                                                 *     // Target object deeply (but not strictly) includes `x: {a: 1}`
           *                                                    *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
           *                                                       *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
           *                                                          *
           *                                                             *     // Target array deeply (but not strictly) has member `{a: 1}`
           *                                                                *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
           *                                                                   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
           *                                                                      *
           *                                                                         *     // Target set deeply (but not strictly) has key `{a: 1}`
           *                                                                            *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
           *                                                                               *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
           *                                                                                  *
           *                                                                                     *     // Target object deeply (but not strictly) has property `x: {a: 1}`
           *                                                                                        *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
           *                                                                                           *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
           *                                                                                              *
           *                                                                                                 * @name deep
           *                                                                                                    * @namespace BDD
           *                                                                                                       * @api public
           *                                                                                                          */

        Assertion.addProperty('deep', function () {
              flag(this, 'deep', true);
                
        });

          /**
           *    * ### .nested
           *       *
           *          * Enables dot- and bracket-notation in all `.property` and `.include`
           *             * assertions that follow in the chain.
           *                *
           *                   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
           *                      *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
           *                         *
           *                            * If `.` or `[]` are part of an actual property name, they can be escaped by
           *                               * adding two backslashes before them.
           *                                  *
           *                                     *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
           *                                        *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
           *                                           *
           *                                              * `.nested` cannot be combined with `.own`.
           *                                                 *
           *                                                    * @name nested
           *                                                       * @namespace BDD
           *                                                          * @api public
           *                                                             */
  }
}]})})
